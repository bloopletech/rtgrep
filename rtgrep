#!/usr/bin/env ruby

require 'rbcurse/core/util/app'

$datacolor = $normalcolor = $def_fg_color = 238
$def_bg_color = 16
$log = Logger.new("/dev/null")

MAP_KIND = ENV["RTGREP_MAP_KIND"]
require File.dirname(__FILE__) + "/map_kind.rb" if MAP_KIND

class Searcher
  def initialize
    @haystacks = {}
    @haystack = []
  end

  def add(file)
    @haystacks[file] = {} unless @haystacks.key?(file)
    @haystacks[file].merge!(:mtime => File.mtime(file), :lines => nil)
  end

  def delete(file)
    @haystacks.delete(file)
  end

  def update
    @haystacks.each_pair do |name, value|
#      current_mtime = File.lstat(name).mtime
      current_mtime = File.mtime(name)
      if value[:lines].nil? || (current_mtime > value[:mtime])
        value[:lines] = Searcher.parse_ctagsx(File.readlines(name).map { |s| s.chomp }.select { |s| s != "" })
        value[:mtime] = current_mtime
      end
    end

    @haystack = @haystacks.values.map { |v| v[:lines] }.flatten(1)
  end

  def search(needle = nil)
    return @haystack if !needle || needle.gsub(' ', '') == ''

    needle_parts = needle.split("").map do |c|
      c = Regexp.escape(c)
      "#{c}[^#{c}]*?"
    end.join
    needle_regex = Regexp.new(needle_parts, "i")
    #needle_regex = Regexp.new(needle.split("").map { |c| "#{c}?[^#{c}]*?" }.join, "i")
    matching_lines = @haystack.select { |line| line[0] =~ needle_regex }
    longest_line = matching_lines.max_by { |line| line[0].length }
    longest_line_length = longest_line[0].length

    sort_data = matching_lines.map do |line|
      shortest_match = nil
      line[0].to_enum(:scan, needle_regex).map do
        match_data = Regexp.last_match
        puts "match_data: #{match_data.inspect}"
        offset = match_data.offset(0)
        if !shortest_match || ((offset[1] - offset[0]) < (shortest_match[1] - shortest_match[0]))
          shortest_match = offset
        end
      end
      puts "line[0]: #{line[0]}"
      puts "shortest_match: #{shortest_match.inspect}, #{shortest_match[1] - shortest_match[0]}"


      match_length_mod = ((shortest_match[1] - shortest_match[0]) / needle.length).to_f
      puts "match_length_mod: #{match_length_mod}"
      match_position_mod = shortest_match[0]
      puts "match_position_mod: #{match_position_mod}"

      line_length_mod = line[0].length
      puts "line_length_mod: #{line_length_mod}"

      [line, match_length_mod, match_position_mod, line_length_mod]
    end
    sort_data.sort do |a, b|
      if a[1] < b[1] #Shortest match length/needle length ratio
        -1
      elsif a[1] > b[1]
        1
      else
        if a[2] < b[2] #Shortest match position in string
          -1
        elsif a[2] > b[2]
          1
        else
#          if a[0][3].length < b[0][3].length
#            -1
#          elsif a[0][3].length > b[0][3].length
#            1
#          else
#            if a[0][3] < b[0][3] #Match file path
#              -1
#            elsif a[0][3] > b[0][3]
#              1
#            else
#              a[0][2].to_i <=> b[0][2].to_i #Match file line number
#            end
#          end
#          puts "a[0]: #{a[0].inspect}"
#          puts "a[0][3]: #{a[0][3]}, b[0][3]: #{b[0][3]}"
          if a[0][3] == b[0][3]
            puts "doing cmp"
            a[0][2].to_i <=> b[0][2].to_i
          elsif a[3] < b[3]
            -1
          elsif a[3] > b[3]
            1
          else
            a[0][3] <=> b[0][3]
          end
        end
      end
    end.map do |sd|
      sd[0]
    end
  end


  def self.parse_ctagsx(lines)
    lines.map! do |l|
      l =~ /^(.+?) +([\w ]+?) +(\d+?) +([^ ]+?) +(.*?)$/
      [$1, $2, $3, $4, $5]
    end
    regex = /^#{Regexp.quote(Dir.getwd() + File::SEPARATOR)}/
    lines.each do |l|
      l[0].gsub!("\x00", " ")
      l[0].replace l[0][0..100]
      l[3].slice!(regex)
    end
    lines.each { |l| l[1] = KINDS_MAP[l[1]] } if MAP_KIND
    lines
  end
end

class SearcherList < RubyCurses::List
  def convert_value_to_text(value, crow)
    value
  end

  def highlight_focussed_row type, r=nil, c=nil, acolor=nil
    return unless @should_show_focus
    case type
    when :FOCUSSED
      ix = @current_index
      return if is_row_selected ix
      r = _convert_index_to_printable_row() unless r
      focussed = true

    when :UNFOCUSSED
      return if @oldrow.nil? || @oldrow == @current_index
      ix = @oldrow
      return if is_row_selected ix
      r = _convert_index_to_printable_row(@oldrow) unless r
      return unless r # row is not longer visible
      focussed = false
    end
    unless c
      _r, c = rowcol
    end

    @cell_renderer.repaint(@graphic, r, c, ix, list()[ix], focussed, false)
  end

=begin
  def highlight_selected_row r=nil, c=nil, acolor=nil
    return unless @selected_index # no selection
    r = _convert_index_to_printable_row(@selected_index) unless r
    return unless r # not on screen
    unless c
      _r, c = rowcol
    end
    STDERR.puts "r: #{r}, c: #{c}"
    @cell_renderer.repaint(@graphic, r, c, @selected_index, list()[@selected_index], false, true)
  end
  def unhighlight_row index,  r=nil, c=nil, acolor=nil
    return unless index # no selection
    r = _convert_index_to_printable_row(index) unless r
    return unless r # not on screen
    unless c
      _r, c = rowcol
    end
    @cell_renderer.repaint(@graphic, r, c, index, list()[index], false, false)
  end
=end

  def handle_key(ch)
    case ch
    when Ncurses::KEY_NPAGE, Ncurses::KEY_PPAGE
      if ch == Ncurses::KEY_NPAGE
        @toprow += height
      else
        @toprow -= height
      end
      @toprow = 0 if @toprow < 0 #The opposite case is handled inside bounds_check
      @oldrow = @current_index
      @current_index = @toprow
      bounds_check
      @repaint_required = true
      @widget_scrolled = true
    else
      super
    end
  end
end

class SearcherListCellRenderer < RubyCurses::ListCellRenderer
  def repaint graphic, r=@row,c=@col, row_index=-1,value=@text, focussed=false, selected=false
    if focussed
      offset = 236
      attr_offset = Ncurses::A_NORMAL
    else
      offset = 0
      attr_offset = Ncurses::A_NORMAL
    end

    chunks = [Chunks::Chunk.new(ColorMap.get_color(252, offset), value[0], Ncurses::A_BOLD), Chunks::Chunk.new(ColorMap.get_color(252, offset), value[1], attr_offset)]
    chunks.reverse! if MAP_KIND

    if value[0] != value[3]
      chunks << Chunks::Chunk.new(ColorMap.get_color(245, offset), value[3], attr_offset)
      if value[2] != "1"
        chunks << Chunks::Chunk.new(ColorMap.get_color(245, offset), value[2], attr_offset)
      end
    end

    blank = Chunks::Chunk.new(ColorMap.get_color(252, offset), ' ', attr_offset)
    chunk_line = Chunks::ChunkLine.new(chunks.flat_map { |c| [c, blank] }[0...-1])
    fill_length = (@display_length - chunk_line.length) 
    chunk_line << Chunks::Chunk.new(ColorMap.get_color(252, offset), " " * fill_length, attr_offset) if fill_length > 0

    graphic.wmove r, c
    graphic.show_colored_chunks chunk_line, ColorMap.get_color(238), nil
  end
end

class SearcherField < RubyCurses::Field
  def searcher_list(list)
    @searcher_list = list
  end

  def handle_key(ch)
    if ((32..126).to_a + @key_handler.keys + [13]).include?(ch)
      super
    else
      @searcher_list.handle_key(ch)
      focus
    end
  end
end

if ENV["TMUX"]
  module InterruptibleSleep
    def self.interruptible_sleep(seconds)
      @_sleep_check, @_sleep_interrupt = IO.pipe
      IO.select([@_sleep_check], nil, nil, seconds)
    end
   
    def self.interrupt_sleep
      @_sleep_interrupt.close if @_sleep_interrupt
    end
  end

  Signal.trap("HUP") do
    InterruptibleSleep.interrupt_sleep
  end

  PID_FILE = "#{ENV["RTGREP_PATH"]}_pid"

  File.open(PID_FILE, "w") do |f|
    f << Process.pid
  end

  at_exit do
    File.delete(PID_FILE)
  end
end

App.new do
  @default_prefix = " "

  searcher = Searcher.new
  ARGV.each { |a| searcher.add(a) }
  searcher.update

  stack :margin_top => 0, :width => :expand, :height => FFI::NCurses.LINES, :color => $normalcolor, :bgcolor => $def_bg_color do
    results_box = SearcherList.new(nil, :list => searcher.search, :width => :expand, :height => FFI::NCurses.LINES - 2, :selection_mode => :single, :suppress_borders => true)
    _position(results_box)
    results_box.instance_variable_set("@display_length", 9001)
    results_box.cell_renderer(SearcherListCellRenderer.new(:display_length => results_box.width))

    label :text => " ", :width => :expand, :height => 1

    search_box = SearcherField.new(nil, :label => "Search >", :searcher_list => results_box)
    _position(search_box)

    exit_proc = proc do
      if ENV["TMUX"]
        system("tmux detach-client")

        InterruptibleSleep.interruptible_sleep 10000

        searcher.update
        search_box.text = ""
        search_box.focus
        search_box.cursor_home

        @form.widgets.each { |w| w.repaint_all }
        @form.repaint
      else
        throw(:close)
      end
    end

    search_box.bind(:CHANGE) do
      results_box.list(searcher.search(search_box.getvalue))
      results_box.goto_top
    end
    search_box.bind_key(13) do
      selected_tag = results_box.current_value

      if selected_tag
        io = ENV["TMUX"] ? File.open("#{ENV["RTGREP_PATH"]}_output", "w") : STDERR
        io.print "#{selected_tag[3]}\n#{selected_tag[2]}\n#{selected_tag[4]}\n"
        io.flush
      end

      exit_proc.call
    end
    search_box.bind_key(2727) do
      exit_proc.call
    end

    search_box.focus
    search_box.cursor_home
  end
end
