#!/usr/bin/env ruby

require 'rbcurse/core/util/app'

$datacolor = $normalcolor = $def_fg_color = 238
$def_bg_color = 16
$log = Logger.new("/dev/null")

MAP_KIND = ENV["RTGREP_MAP_KIND"]
require File.dirname(__FILE__) + "/map_kind.rb" if MAP_KIND

class Searcher
  def initialize(haystack)
    @haystack = haystack
  end

  def self.parse_ctagsx(lines)
    lines.map! do |l|
      l =~ /^(.+?) +([\w ]+?) +(\d+?) +([^ ]+?) +(.*?)$/
      [$1, $2, $3, $4, $5]
    end
    regex = /^#{Regexp.quote(Dir.getwd() + File::SEPARATOR)}/
    lines.each do |l|
      l[0].gsub!("\x00", " ")
      l[0].replace l[0][0..100]
      l[3].slice!(regex)
    end
    lines.each { |l| l[1] = KINDS_MAP[l[1]] } if MAP_KIND
    lines
  end

  def search(needle = nil)
    return @haystack if !needle || needle.gsub(' ', '') == ''

    needle_parts = needle.split("").map do |c|
      c = Regexp.escape(c)
      "#{c}[^#{c}]*?"
    end.join
    needle_regex = Regexp.new(needle_parts, "i")
    #needle_regex = Regexp.new(needle.split("").map { |c| "#{c}?[^#{c}]*?" }.join, "i")
    @haystack.select { |line| line[0] =~ needle_regex }.sort_by do |line|
      shortest_match = nil
      line[0].to_enum(:scan, needle_regex).map do
        match_data = Regexp.last_match
        offset = match_data.offset(0)
        if !shortest_match || ((offset[1] - offset[0]) < (shortest_match[1] - shortest_match[0]))
          shortest_match = offset
        end
      end

      ((shortest_match[0]) * 1.0) + ((shortest_match[1] - shortest_match[0]) * 0.5) + ((line[0].length) * 0.3)
    end
  end
end

class SearcherList < RubyCurses::List
  def convert_value_to_text(value, crow)
    value
  end

  def highlight_focussed_row type, r=nil, c=nil, acolor=nil
    return unless @should_show_focus
    case type
    when :FOCUSSED
      ix = @current_index
      return if is_row_selected ix
      r = _convert_index_to_printable_row() unless r
      focussed = true

    when :UNFOCUSSED
      return if @oldrow.nil? || @oldrow == @current_index
      ix = @oldrow
      return if is_row_selected ix
      r = _convert_index_to_printable_row(@oldrow) unless r
      return unless r # row is not longer visible
      focussed = false
    end
    unless c
      _r, c = rowcol
    end

    @cell_renderer.repaint(@graphic, r, c, ix, list()[ix], focussed, false)
  end

=begin
  def highlight_selected_row r=nil, c=nil, acolor=nil
    return unless @selected_index # no selection
    r = _convert_index_to_printable_row(@selected_index) unless r
    return unless r # not on screen
    unless c
      _r, c = rowcol
    end
    STDERR.puts "r: #{r}, c: #{c}"
    @cell_renderer.repaint(@graphic, r, c, @selected_index, list()[@selected_index], false, true)
  end
  def unhighlight_row index,  r=nil, c=nil, acolor=nil
    return unless index # no selection
    r = _convert_index_to_printable_row(index) unless r
    return unless r # not on screen
    unless c
      _r, c = rowcol
    end
    @cell_renderer.repaint(@graphic, r, c, index, list()[index], false, false)
  end
=end

  def handle_key(ch)
    case ch
    when Ncurses::KEY_NPAGE, Ncurses::KEY_PPAGE
      if ch == Ncurses::KEY_NPAGE
        @toprow += height
      else
        @toprow -= height
      end
      @toprow = 0 if @toprow < 0 #The opposite case is handled inside bounds_check
      @oldrow = @current_index
      @current_index = @toprow
      bounds_check
      @repaint_required = true
      @widget_scrolled = true
    else
      super
    end
  end
end

class SearcherListCellRenderer < RubyCurses::ListCellRenderer
  def repaint graphic, r=@row,c=@col, row_index=-1,value=@text, focussed=false, selected=false
    if focussed
      offset = 236
      attr_offset = Ncurses::A_NORMAL
    else
      offset = 0
      attr_offset = Ncurses::A_NORMAL
    end

    chunks = [Chunks::Chunk.new(ColorMap.get_color(252, offset), value[0], Ncurses::A_BOLD), Chunks::Chunk.new(ColorMap.get_color(252, offset), value[1], attr_offset)]
    chunks.reverse! if MAP_KIND

    if value[0] != value[3]
      chunks << Chunks::Chunk.new(ColorMap.get_color(245, offset), value[3], attr_offset)
      if value[2] != "1"
        chunks << Chunks::Chunk.new(ColorMap.get_color(245, offset), value[2], attr_offset)
      end
    end

    blank = Chunks::Chunk.new(ColorMap.get_color(252, offset), ' ', attr_offset)
    chunk_line = Chunks::ChunkLine.new(chunks.flat_map { |c| [c, blank] }[0...-1])
    fill_length = (@display_length - chunk_line.length) 
    chunk_line << Chunks::Chunk.new(ColorMap.get_color(252, offset), " " * fill_length, attr_offset) if fill_length > 0

    graphic.wmove r, c
    graphic.show_colored_chunks chunk_line, ColorMap.get_color(238), nil
  end
end

class SearcherField < RubyCurses::Field
  def searcher_list(list)
    @searcher_list = list
  end

  def handle_key(ch)
    $log.debug "ZZZZZZZZZZZZZZZZZZZ #{ch.inspect}"
    if ((32..126).to_a + @key_handler.keys + [13]).include?(ch)
      super
    else
      @searcher_list.handle_key(ch)
      focus
    end
  end
end



App.new do
  selected_tag = [""]

  at_exit do
    STDERR.print "#{selected_tag[3]}\n#{selected_tag[2]}\n#{selected_tag[4]}\n" if selected_tag
  end

  @default_prefix = " "

  lines = Searcher.parse_ctagsx(ARGF.readlines.map { |s| s.chomp })
  searcher = Searcher.new(lines)

  stack :margin_top => 0, :width => :expand, :height => FFI::NCurses.LINES, :color => $normalcolor, :bgcolor => $def_bg_color do
    results_box = SearcherList.new(nil, :list => searcher.search, :width => :expand, :height => FFI::NCurses.LINES - 2, :selection_mode => :single, :suppress_borders => true)
    _position(results_box)
    results_box.instance_variable_set("@display_length", 9001)
    results_box.cell_renderer(SearcherListCellRenderer.new(:display_length => results_box.width))

    label :text => " ", :width => :expand, :height => 1

    search_box = SearcherField.new(nil, :label => "Search >", :searcher_list => results_box)
    _position(search_box)
    search_box.bind(:CHANGE) do
      results_box.list(searcher.search(search_box.getvalue))
      results_box.goto_top
    end
    search_box.bind_key(13) do
      selected_tag = results_box.current_value
      throw(:close)
    end
    search_box.bind_key(2727) do
      selected_tag = nil
      throw(:close)
    end

    search_box.focus
    search_box.cursor_home
  end
end
