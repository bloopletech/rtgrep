#!/usr/bin/env ruby

require 'rbcurse/core/util/app'
if Rbcurse::VERSION != "0.0.3"
  puts <<-EOF
This script is written against rbcurse-core version 0.0.3;
there are brittle dependencies against the particular version of rbcurse-core
(mainly because of apparent bugs in rb-curse core).
Please run this script against the correct version of rbcurse-core (0.0.3).
EOF
  exit
end

$datacolor = $normalcolor = $def_fg_color = 238
$actual_bg_color = 16
$def_bg_color = $actual_bg_color + 0

module ColorMap
  class << self
    alias_method :original_get_color_const, :get_color_const
  end
  def ColorMap.get_color_const colorstring
    if [:black, "black", 0, nil].include?(colorstring)
      return $actual_bg_color
    else
      original_get_color_const(colorstring)
    end
  end
end

$log = Logger.new("/dev/null")
#$tlg = Logger.new("/home/bloopletech/tlg.log")

FILE_MARKER = "rtgrep file marker"

class Searcher
  def initialize
    @haystacks = {}
    @haystack = nil
  end

  def add(file)
    @haystacks[file] = {} unless @haystacks.key?(file)
    @haystacks[file].merge!(:lines => nil)
  end

  def delete(file)
    @haystacks.delete(file)
  end

  def update
    @haystacks.each_pair do |name, value|
      current_mtime = File.mtime(name)
      current_symlink = File.symlink?(name)
      current_lmtime = current_symlink ? File.lstat(name).mtime : nil
      if value[:lines].nil? || (current_mtime != value[:mtime]) || (current_lmtime != value[:lmtime]) || (current_symlink != value[:symlink])
        value[:lines] = Searcher.parse_vimtags(File.readlines(name).map { |s| s.chomp }.select { |s| s != "" })
        value[:lines].unshift([File.basename(name), FILE_MARKER, "", "", ""]) unless value[:lines].empty?
        value[:mtime] = current_mtime
        value[:lmtime] = current_lmtime
        value[:symlink] = current_symlink
      end
    end

    @haystack = @haystacks.values.map { |v| v[:lines] }.flatten(1)

    @longest_line_length = (@haystack.max_by { |line| line[0].length }).first.length
    @longest_filename_length = (@haystack.max_by { |line| line[3].length }).first.length

    @last_matches = []
    @last_needle = nil
  end

  def search(needle = nil)
    raise "You must call Searcher#update before calling Searcher#search, and you must have at least one file added to the searcher using Searcher#add." unless @haystack
    return @haystack if !needle || needle.gsub(' ', '') == ''

    needle_parts = needle.split("").map do |c|
      c = Regexp.escape(c)
      "#{c}([^#{c}]*?)"
    end.join
    needle_regex = Regexp.new(needle_parts, "i")
    #needle_regex = Regexp.new(needle.split("").map { |c| "#{c}?[^#{c}]*?" }.join, "i")

    matching_lines = if @last_needle && needle.start_with?(@last_needle)
      #$tlg.error "Using last matches cache, last_needle: #{@last_needle.inspect}, needle: #{needle.inspect}, search space reduced from #{@haystack.length} to #{@last_matches.length}"
      @last_matches
    else
      #$tlg.error "SKIPPING last matches cache, last_needle: #{@last_needle.inspect}, needle: #{needle.inspect}, search space widened from #{@last_matches.length} to #{@haystack.length}"
      @haystack.reject { |line| line[1] == FILE_MARKER } 
    end

    @last_needle = needle.dup
    @last_matches = matching_lines = matching_lines.select { |line| line[0] =~ needle_regex }

    matching_lines.sort_by do |line|
      shortest_match_offset = nil
      shortest_match_inbetweens = nil
      line[0].to_enum(:scan, needle_regex).map do
        match_data = Regexp.last_match

        offset = match_data.offset(0)
        if !shortest_match_offset || ((offset[1] - offset[0]) < (shortest_match_offset[1] - shortest_match_offset[0]))
          shortest_match_offset = offset
          shortest_match_inbetweens = match_data.captures.inject(0) { |sum, c| sum + c.length }
        end
      end

      match_line_length_mod = 1 - ((shortest_match_offset[1] - shortest_match_offset[0]) / line[0].length.to_f)
      match_inbetweens_length_mod = shortest_match_inbetweens / line[0].length.to_f
      match_position_mod = (shortest_match_offset[0] + 1) / line[0].length.to_f
      file_length_mod = line[3].length / @longest_filename_length.to_f
      line_length_mod = line[0].length / @longest_line_length.to_f

      score = (match_line_length_mod * 10.0) + (match_inbetweens_length_mod * 10.0) + (match_position_mod * 10.0) + (file_length_mod * 2.0) + (line_length_mod * 2.0)

#      $tlg.debug "\n\n\n\nNeedle: #{needle.inspect}\nLine:\n#{line.inspect}\nShortest match offset: #{shortest_match_offset.inspect}\nShortest match inbetweens: #{shortest_match_inbetweens.inspect}\nmatch_length_mod: #{match_length_mod}, match_inbetweens_length_mod: #{match_inbetweens_length_mod}, file_length_mod: #{file_length_mod}, match_line_length_mod: #{match_line_length_mod}, match_position_mod: #{match_position_mod}, line_length_mod: #{line_length_mod}\nResult: #{result}"

       score
    end
  end


  def self.parse_vimtags(lines)
    regex = /^#{Regexp.quote(Dir.getwd() + File::SEPARATOR)}/
    lines.reject! { |l| l =~ /^\!_TAG_/ }
    lines.map! do |l|
      begin
        l =~ /^(.+?)\t(.+?)\t(.+?)(;"(.+)|)$/
        l = [$1, $5, $3, $2, ""] #0 = tag, 1 = type, 2 = line num, 3 = path, 4 = line context

        extra = l[1]
        if extra
          extra =~ /^\t(.)/
          type = $1
          l[1] = type
        end

        l[0].replace l[0][0..100]
        l[3].slice!(regex)
        l
      rescue
      end
    end
    lines
  end
end

class SearcherList < RubyCurses::List
  def convert_value_to_text(value, crow)
    value
  end

  def highlight_focussed_row type, r=nil, c=nil, acolor=nil
    return unless @should_show_focus
    case type
    when :FOCUSSED
      ix = @current_index
      return if is_row_selected ix
      r = _convert_index_to_printable_row() unless r
      focussed = true

    when :UNFOCUSSED
      return if @oldrow.nil? || @oldrow == @current_index
      ix = @oldrow
      return if is_row_selected ix
      r = _convert_index_to_printable_row(@oldrow) unless r
      return unless r # row is not longer visible
      focussed = false
    end
    unless c
      _r, c = rowcol
    end

    @cell_renderer.repaint(@graphic, r, c, ix, list()[ix], focussed, false)
  end

=begin
  def highlight_selected_row r=nil, c=nil, acolor=nil
    return unless @selected_index # no selection
    r = _convert_index_to_printable_row(@selected_index) unless r
    return unless r # not on screen
    unless c
      _r, c = rowcol
    end
    STDERR.puts "r: #{r}, c: #{c}"
    @cell_renderer.repaint(@graphic, r, c, @selected_index, list()[@selected_index], false, true)
  end
  def unhighlight_row index,  r=nil, c=nil, acolor=nil
    return unless index # no selection
    r = _convert_index_to_printable_row(index) unless r
    return unless r # not on screen
    unless c
      _r, c = rowcol
    end
    @cell_renderer.repaint(@graphic, r, c, index, list()[index], false, false)
  end
=end

  def handle_key(ch)
    case ch
    when Ncurses::KEY_NPAGE, Ncurses::KEY_PPAGE
      if ch == Ncurses::KEY_NPAGE
        @toprow += height
      else
        @toprow -= height
      end
      @toprow = 0 if @toprow < 0 #The opposite case is handled inside bounds_check
      @oldrow = @current_index
      @current_index = @toprow
      bounds_check
      @repaint_required = true
      @widget_scrolled = true
    else
      super
    end
  end

  def on_enter_row arow
    super
    if current_value[1] == FILE_MARKER
      if @current_index > @oldrow
        if next_row == :NO_NEXT_ROW
          previous_row
        end
      elsif @current_index < @oldrow
        if previous_row == :NO_PREVIOUS_ROW
          next_row
        end
      end
    end
  end

  def goto_top
    @current_index = -1
    super
  end
end

class SearcherListCellRenderer < RubyCurses::ListCellRenderer
  def repaint graphic, r=@row,c=@col, row_index=-1,value=@text, focussed=false, selected=false
    if focussed
      offset = 236
      attr_offset = Ncurses::A_NORMAL
    else
      offset = 0
      attr_offset = Ncurses::A_NORMAL
    end

    chunk_line = nil

    if value[1] == FILE_MARKER
      marker = "# #{value[0].gsub("_", " ").upcase} "
      marker += "#" * [@display_length - marker.length, 0].max
      marker = marker[0..(@display_length)]
      chunk_line = Chunks::ChunkLine.new([Chunks::Chunk.new(ColorMap.get_color(252, offset), marker, Ncurses::A_BOLD)])
    else
      chunks = [Chunks::Chunk.new(ColorMap.get_color(11, offset), value[1], attr_offset), Chunks::Chunk.new(ColorMap.get_color(252, offset), value[0], Ncurses::A_BOLD)]

      if value[0] != value[3]
        chunks << Chunks::Chunk.new(ColorMap.get_color(245, offset), value[3], attr_offset)
        if value[2] != "1"
          chunks << Chunks::Chunk.new(ColorMap.get_color(245, offset), value[2], attr_offset)
        end
      end

      blank = Chunks::Chunk.new(ColorMap.get_color(252, offset), ' ', attr_offset)
      chunk_line = Chunks::ChunkLine.new(chunks.flat_map { |c| [c, blank] }[0...-1])
      fill_length = (@display_length - chunk_line.length)
      chunk_line << Chunks::Chunk.new(ColorMap.get_color(252, offset), " " * fill_length, attr_offset) if fill_length > 0
    end

    graphic.wmove r, c
    graphic.show_colored_chunks chunk_line, ColorMap.get_color(238), nil
  end
end

class SearcherField < RubyCurses::Field
  def searcher_list(list)
    @searcher_list = list
  end

  def handle_key(ch)
    if ((32..126).to_a + @key_handler.keys + [13]).include?(ch)
      super
    else
      @searcher_list.handle_key(ch)
      focus
    end
  end
end

if ENV["RTGREP_PATH"]
  module InterruptibleSleep
    def self.interruptible_sleep(seconds)
      @_sleep_check, @_sleep_interrupt = IO.pipe
      IO.select([@_sleep_check], nil, nil, seconds)
    end
   
    def self.interrupt_sleep
      @_sleep_interrupt.close if @_sleep_interrupt
    end
  end

  Signal.trap("HUP") do
    InterruptibleSleep.interrupt_sleep
  end

  PID_FILE = "#{ENV["RTGREP_PATH"]}_pid"

  File.open(PID_FILE, "w") do |f|
    f << Process.pid
  end

  at_exit do
    File.delete(PID_FILE)
  end
end



App.new do
  @default_prefix = " "

  searcher = Searcher.new
  ARGV.each { |a| searcher.add(a) }
  searcher.update

  stack :margin_top => 0, :width => :expand, :height => FFI::NCurses.LINES, :color => $normalcolor, :bgcolor => $actual_bg_color do
    results_box = SearcherList.new(nil, :list => searcher.search, :width => :expand, :height => FFI::NCurses.LINES - 2, :selection_mode => :single, :suppress_borders => true)
    _position(results_box)
    results_box.instance_variable_set("@display_length", FFI::NCurses.COLS)
    results_box.instance_variable_set("@internal_width", 0)
    results_box.cell_renderer(SearcherListCellRenderer.new(:display_length => results_box.width))

    label :text => " ", :width => :expand, :height => 1

    search_box = SearcherField.new(nil, :label => "Search >", :searcher_list => results_box)
    _position(search_box)
    field_width = FFI::NCurses.COLS - search_box.label.length - 2
    search_box.instance_variable_set("@display_length", field_width)
    search_box.instance_variable_set("@maxlen", field_width)

    exit_proc = proc do
      if ENV["RTGREP_PATH"]
        system("tmux detach-client")

        InterruptibleSleep.interruptible_sleep 10000

        searcher.update
        search_box.text = ""
        search_box.focus
        search_box.cursor_home

        @form.widgets.each { |w| w.repaint_all }
        @form.repaint
      else
        throw(:close)
      end
    end

    search_box.bind(:CHANGE) do |event|
      results_box.list(searcher.search(search_box.getvalue))
      results_box.goto_top
      search_box.focus
      search_box.addcol(case event.type
      when :INSERT
        -1
      when :DELETE
        1
      else
        nil
      end)
    end

    search_box.bind_key(13) do
      selected_tag = results_box.current_value

      if selected_tag
        io = ENV["RTGREP_PATH"] ? File.open("#{ENV["RTGREP_PATH"]}_output", "w") : STDERR
        io.print "#{selected_tag[3]}\n#{selected_tag[2]}\n#{selected_tag[4]}\n"
        io.flush
      end

      exit_proc.call
    end

    search_box.bind_key(2727) do
      exit_proc.call
    end

    if ENV["RTGREP_TAGGER"]
      search_box.bind_key(FFI::NCurses::KEY_F5) do
        system("#{ENV["RTGREP_TAGGER"]} >/dev/null")
        searcher.update
        results_box.list(searcher.search(search_box.getvalue))
        search_box.fire_handler :CHANGE, InputDataEvent.new(nil, nil, nil, nil, nil, nil)
      end
    end

    @window.printstring(FFI::NCurses.LINES - 1, search_box.label.length, "  ", $actual_bg_color)
    results_box.goto_top
    search_box.focus
    search_box.cursor_home
  end
end
